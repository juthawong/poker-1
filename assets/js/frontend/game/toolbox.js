// Generated by CoffeeScript 1.10.0
(function() {
  var binarySearch, constants, getAllPairValuesAtHandForSuit, getAllValuesOfMainAndMainSuit, getCardName, getCardValuesForSuit, getRanksForMainSuitCards, getRelativeMainSuitValues, getStartAndEndValueForSuit, globalVariables, havePairForMainSuit, havePairForSuit, haveSingleForMainSuit, haveSingleForSuit, haveTractorForMainSuit, haveTractorForSuit, isPairForMainSuit, isPairForSuit, isSingleForMainSuit, isSingleForSuit, isTractorForMainSuit, isTractorForSuit, setPlayerStatusTextForOneUserAndClearStatusTextForOthers, sortCards, sortCardsAfterMainSuitSettled, validateSelectedCardsForPlay,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  constants = require('./constants.js');

  globalVariables = require('./globalVariables.js');

  binarySearch = function(array, x) {
    var begin, end, mid, n, result;
    n = array.length;
    begin = 0;
    end = n - 1;
    result = -1;
    while (begin <= end) {
      mid = Math.floor((begin + end) / 2);
      if (array[mid] <= x) {
        begin = mid + 1;
        result = mid;
      } else {
        end = mid - 1;
      }
    }
    return result;
  };

  sortCards = function(array) {
    var sortNumber;
    sortNumber = function(a, b) {
      return a - b;
    };
    return array.sort(sortNumber);
  };

  sortCardsAfterMainSuitSettled = function(array, mainSuit) {
    var cardValuesForMain, cardValuesForMainSuit, i, index, indexForDiamondSeven, indexForSmallJoker, indexesForMainSevens, indexesForMainTwos, j, k, l, m, mainSeven, mainTwo, o, ref, ref1, ref2, ref3, ref4;
    array = sortCards(array);
    cardValuesForMainSuit = getCardValuesForSuit(mainSuit, array);
    cardValuesForMain = getCardValuesForSuit(constants.INDEX_SUIT_MAIN, array);
    if (cardValuesForMain.length !== 0) {
      indexesForMainSevens = [];
      indexesForMainTwos = [];
      mainSeven = null;
      mainTwo = null;
      switch (mainSuit) {
        case constants.INDEX_SUIT_SPADE:
          mainSeven = constants.VALUE_SPADE_SEVEN;
          mainTwo = constants.VALUE_SPADE_TWO;
          break;
        case constants.INDEX_SUIT_HEART:
          mainSeven = constants.VALUE_HEART_SEVEN;
          mainTwo = constants.VALUE_HEART_TWO;
          break;
        case constants.INDEX_SUIT_CLUB:
          mainSeven = constants.VALUE_CLUB_SEVEN;
          mainTwo = constants.VALUE_CLUB_TWO;
          break;
        case constants.INDEX_SUIT_DIAMOND:
          mainSeven = constants.VALUE_DIAMOND_SEVEN;
          mainTwo = constants.VALUE_DIAMOND_TWO;
      }
      for (i = j = 0, ref = cardValuesForMain.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (cardValuesForMain[i] === mainSeven) {
          indexesForMainSevens.push(i);
        }
      }
      if (indexesForMainSevens.length === 1) {
        cardValuesForMain.splice(indexesForMainSevens[0], 1);
        indexForSmallJoker = binarySearch(cardValuesForMain, constants.VALUE_SMALL_JOKER);
        cardValuesForMain.splice(indexForSmallJoker + 1, 0, mainSeven);
      } else if (indexesForMainSevens.length === 2) {
        cardValuesForMain.splice(indexesForMainSevens[0], 2);
        indexForSmallJoker = binarySearch(cardValuesForMain, constants.VALUE_SMALL_JOKER);
        cardValuesForMain.splice(indexForSmallJoker + 1, 0, mainSeven);
        cardValuesForMain.splice(indexForSmallJoker + 1, 0, mainSeven);
      }
      for (i = k = 0, ref1 = cardValuesForMain.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
        if (cardValuesForMain[i] === mainTwo) {
          indexesForMainTwos.push(i);
        }
      }
      if (indexesForMainTwos.length === 1) {
        cardValuesForMain.splice(indexesForMainTwos[0], 1);
        indexForDiamondSeven = binarySearch(cardValuesForMain, constants.VALUE_DIAMOND_SEVEN);
        cardValuesForMain.splice(indexForDiamondSeven + 1, 0, mainTwo);
      } else if (indexesForMainTwos.length === 2) {
        cardValuesForMain.splice(indexesForMainTwos[0], 2);
        indexForDiamondSeven = binarySearch(cardValuesForMain, constants.VALUE_DIAMOND_SEVEN);
        cardValuesForMain.splice(indexForDiamondSeven + 1, 0, mainTwo);
        cardValuesForMain.splice(indexForDiamondSeven + 1, 0, mainTwo);
      }
      for (i = l = 0, ref2 = cardValuesForMain.length; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        index = array.indexOf(cardValuesForMain[i]);
        array.splice(index, 1);
      }
      array = cardValuesForMain.concat(array);
    }
    if (cardValuesForMainSuit.length !== 0) {
      for (i = m = 0, ref3 = cardValuesForMainSuit.length; 0 <= ref3 ? m < ref3 : m > ref3; i = 0 <= ref3 ? ++m : --m) {
        index = array.indexOf(cardValuesForMainSuit[i]);
        array.splice(index, 1);
      }
      for (i = o = 0, ref4 = cardValuesForMainSuit.length; 0 <= ref4 ? o < ref4 : o > ref4; i = 0 <= ref4 ? ++o : --o) {
        array.splice(cardValuesForMain.length + i, 0, cardValuesForMainSuit[i]);
      }
    }
    return array;
  };


  /*
  With the given card value, this function finds out its corresponding card name
  @param n:                           the card value
  @return string:                     the corresponding card value
   */

  getCardName = function(n) {
    var cardName;
    cardName = '';
    switch (n) {
      case constants.VALUE_BIG_JOKER:
        cardName = 'bigJoker';
        break;
      case constants.VALUE_SMALL_JOKER:
        cardName = 'smallJoker';
        break;
      case constants.VALUE_SPADE_SEVEN:
        cardName = 'sevenOfSpades';
        break;
      case constants.VALUE_HEART_SEVEN:
        cardName = 'sevenOfHearts';
        break;
      case constants.VALUE_CLUB_SEVEN:
        cardName = 'sevenOfClubs';
        break;
      case constants.VALUE_DIAMOND_SEVEN:
        cardName = 'sevenOfDiamonds';
        break;
      case constants.VALUE_SPADE_TWO:
        cardName = 'twoOfSpades';
        break;
      case constants.VALUE_HEART_TWO:
        cardName = 'twoOfHearts';
        break;
      case constants.VALUE_CLUB_TWO:
        cardName = 'twoOfClubs';
        break;
      case constants.VALUE_DIAMOND_TWO:
        cardName = 'twoOfDiamonds';
        break;
      case constants.VALUE_SPADE_ACE:
        cardName = 'aceOfSpades';
        break;
      case constants.VALUE_SPADE_KING:
        cardName = 'kingOfSpades';
        break;
      case constants.VALUE_SPADE_QUEEN:
        cardName = 'queenOfSpades';
        break;
      case constants.VALUE_SPADE_JACK:
        cardName = 'jackOfSpades';
        break;
      case constants.VALUE_SPADE_TEN:
        cardName = 'tenOfSpades';
        break;
      case constants.VALUE_SPADE_NINE:
        cardName = 'nineOfSpades';
        break;
      case constants.VALUE_SPADE_EIGHT:
        cardName = 'eightOfSpades';
        break;
      case constants.VALUE_SPADE_SIX:
        cardName = 'sixOfSpades';
        break;
      case constants.VALUE_SPADE_FIVE:
        cardName = 'fiveOfSpades';
        break;
      case constants.VALUE_HEART_ACE:
        cardName = 'aceOfHearts';
        break;
      case constants.VALUE_HEART_KING:
        cardName = 'kingOfHearts';
        break;
      case constants.VALUE_HEART_QUEEN:
        cardName = 'queenOfHearts';
        break;
      case constants.VALUE_HEART_JACK:
        cardName = 'jackOfHearts';
        break;
      case constants.VALUE_HEART_TEN:
        cardName = 'tenOfHearts';
        break;
      case constants.VALUE_HEART_NINE:
        cardName = 'nineOfHearts';
        break;
      case constants.VALUE_HEART_EIGHT:
        cardName = 'eightOfHearts';
        break;
      case constants.VALUE_HEART_SIX:
        cardName = 'sixOfHearts';
        break;
      case constants.VALUE_HEART_FIVE:
        cardName = 'fiveOfHearts';
        break;
      case constants.VALUE_CLUB_ACE:
        cardName = 'aceOfClubs';
        break;
      case constants.VALUE_CLUB_KING:
        cardName = 'kingOfClubs';
        break;
      case constants.VALUE_CLUB_QUEEN:
        cardName = 'queenOfClubs';
        break;
      case constants.VALUE_CLUB_JACK:
        cardName = 'jackOfClubs';
        break;
      case constants.VALUE_CLUB_TEN:
        cardName = 'tenOfClubs';
        break;
      case constants.VALUE_CLUB_NINE:
        cardName = 'nineOfClubs';
        break;
      case constants.VALUE_CLUB_EIGHT:
        cardName = 'eightOfClubs';
        break;
      case constants.VALUE_CLUB_SIX:
        cardName = 'sixOfClubs';
        break;
      case constants.VALUE_CLUB_FIVE:
        cardName = 'fiveOfClubs';
        break;
      case constants.VALUE_DIAMOND_ACE:
        cardName = 'aceOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_KING:
        cardName = 'kingOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_QUEEN:
        cardName = 'queenOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_JACK:
        cardName = 'jackOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_TEN:
        cardName = 'tenOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_NINE:
        cardName = 'nineOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_EIGHT:
        cardName = 'eightOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_SIX:
        cardName = 'sixOfDiamonds';
        break;
      case constants.VALUE_DIAMOND_FIVE:
        cardName = 'fiveOfDiamonds';
    }
    return cardName;
  };


  /*
  Set status text for one player and clear status text for all other players
  @param: username                                player username whose status text needs to be updated
  @param: statusText                              the status text string
  @return: -
   */

  setPlayerStatusTextForOneUserAndClearStatusTextForOthers = function(username, statusText) {
    globalVariables.meStatusText.text = '';
    globalVariables.player1StatusText.text = '';
    globalVariables.player2StatusText.text = '';
    globalVariables.player3StatusText.text = '';
    if (username === globalVariables.username) {
      return globalVariables.meStatusText.text = statusText;
    } else if (username === globalVariables.player1Username.text) {
      return globalVariables.player1StatusText.text = statusText;
    } else if (username === globalVariables.player2Username.text) {
      return globalVariables.player2StatusText.text = statusText;
    } else if (username === globalVariables.player3Username.text) {
      return globalVariables.player3StatusText.text = statusText;
    }
  };


  /*
  Given a suit index, find out the starting card value and ending card value that belongs to that suit
  @param: suitIndex               the suit index
  @return: array                  an array that contains the starting card value and ending card value that belongs to that suit
   */

  getStartAndEndValueForSuit = function(suitIndex) {
    var endCardValueForSuit, startCardValueForSuit;
    startCardValueForSuit = 0;
    endCardValueForSuit = 0;
    switch (suitIndex) {
      case constants.INDEX_SUIT_MAIN:
        startCardValueForSuit = constants.START_VALUE_FOR_MAIN;
        endCardValueForSuit = constants.END_VALUE_FOR_MAIN;
        break;
      case constants.INDEX_SUIT_SPADE:
        startCardValueForSuit = constants.START_VALUE_FOR_SPADE;
        endCardValueForSuit = constants.END_VALUE_FOR_SPADE;
        break;
      case constants.INDEX_SUIT_HEART:
        startCardValueForSuit = constants.START_VALUE_FOR_HEART;
        endCardValueForSuit = constants.END_VALUE_FOR_HEART;
        break;
      case constants.INDEX_SUIT_CLUB:
        startCardValueForSuit = constants.START_VALUE_FOR_CLUB;
        endCardValueForSuit = constants.END_VALUE_FOR_CLUB;
        break;
      case constants.INDEX_SUIT_DIAMOND:
        startCardValueForSuit = constants.START_VALUE_FOR_DIAMOND;
        endCardValueForSuit = constants.END_VALUE_FOR_DIAMOND;
    }
    return [startCardValueForSuit, endCardValueForSuit];
  };


  /*
  With the given main suit index, rank all card values and return a map that contains the ranking information
  @param: mainSuit            the main suit index
  @return: ranks              the map data structure with format like this:
                              {
                                  valueOfCard1: rank1,
                                  valueOfCard2: rank2,
                                  ...
                              }
   */

  getRanksForMainSuitCards = function(mainSuit) {
    var i, j, k, l, m, nonMainSuitCardStartingRank, o, p, q, r, ranks, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, startingRank, t;
    ranks = {};
    ranks[constants.VALUE_BIG_JOKER] = 1;
    ranks[constants.VALUE_SMALL_JOKER] = 2;
    for (i = j = ref = constants.VALUE_SPADE_SEVEN, ref1 = constants.VALUE_DIAMOND_SEVEN + 1; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      ranks[i] = 4;
    }
    for (i = k = ref2 = constants.VALUE_SPADE_TWO, ref3 = constants.VALUE_DIAMOND_TWO + 1; ref2 <= ref3 ? k < ref3 : k > ref3; i = ref2 <= ref3 ? ++k : --k) {
      ranks[i] = 6;
    }
    nonMainSuitCardStartingRank = 16;
    for (i = l = ref4 = constants.VALUE_SPADE_ACE, ref5 = constants.VALUE_SPADE_FIVE + 1; ref4 <= ref5 ? l < ref5 : l > ref5; i = ref4 <= ref5 ? ++l : --l) {
      ranks[i] = nonMainSuitCardStartingRank + i - constants.VALUE_SPADE_ACE;
    }
    for (i = m = ref6 = constants.VALUE_HEART_ACE, ref7 = constants.VALUE_HEART_FIVE + 1; ref6 <= ref7 ? m < ref7 : m > ref7; i = ref6 <= ref7 ? ++m : --m) {
      ranks[i] = nonMainSuitCardStartingRank + i - constants.VALUE_HEART_ACE;
    }
    for (i = o = ref8 = constants.VALUE_CLUB_ACE, ref9 = constants.VALUE_CLUB_FIVE + 1; ref8 <= ref9 ? o < ref9 : o > ref9; i = ref8 <= ref9 ? ++o : --o) {
      ranks[i] = nonMainSuitCardStartingRank + i - constants.VALUE_CLUB_ACE;
    }
    for (i = p = ref10 = constants.VALUE_DIAMOND_ACE, ref11 = constants.VALUE_DIAMOND_FIVE + 1; ref10 <= ref11 ? p < ref11 : p > ref11; i = ref10 <= ref11 ? ++p : --p) {
      ranks[i] = nonMainSuitCardStartingRank + i - constants.VALUE_DIAMOND_ACE;
    }
    startingRank = 7;
    if (mainSuit === constants.INDEX_SUIT_SPADE) {
      ranks[constants.VALUE_SPADE_SEVEN] = 3;
      ranks[constants.VALUE_SPADE_TWO] = 5;
      for (i = q = ref12 = constants.VALUE_SPADE_ACE, ref13 = constants.VALUE_SPADE_FIVE + 1; ref12 <= ref13 ? q < ref13 : q > ref13; i = ref12 <= ref13 ? ++q : --q) {
        ranks[i] = startingRank + i - constants.VALUE_SPADE_ACE;
      }
    } else if (mainSuit === constants.INDEX_SUIT_HEART) {
      ranks[constants.VALUE_HEART_SEVEN] = 3;
      ranks[constants.VALUE_HEART_TWO] = 5;
      for (i = r = ref14 = constants.VALUE_HEART_ACE, ref15 = constants.VALUE_HEART_FIVE + 1; ref14 <= ref15 ? r < ref15 : r > ref15; i = ref14 <= ref15 ? ++r : --r) {
        ranks[i] = startingRank + i - constants.VALUE_HEART_ACE;
      }
    } else if (mainSuit === constants.INDEX_SUIT_CLUB) {
      ranks[constants.VALUE_CLUB_SEVEN] = 3;
      ranks[constants.VALUE_CLUB_TWO] = 5;
      for (i = s = ref16 = constants.VALUE_CLUB_ACE, ref17 = constants.VALUE_CLUB_FIVE + 1; ref16 <= ref17 ? s < ref17 : s > ref17; i = ref16 <= ref17 ? ++s : --s) {
        ranks[i] = startingRank + i - constants.VALUE_CLUB_ACE;
      }
    } else if (mainSuit === constants.INDEX_SUIT_DIAMOND) {
      ranks[constants.VALUE_DIAMOND_SEVEN] = 3;
      ranks[constants.VALUE_DIAMOND_TWO] = 5;
      for (i = t = ref18 = constants.VALUE_DIAMOND_ACE, ref19 = constants.VALUE_DIAMOND_FIVE + 1; ref18 <= ref19 ? t < ref19 : t > ref19; i = ref18 <= ref19 ? ++t : --t) {
        ranks[i] = startingRank + i - constants.VALUE_DIAMOND_ACE;
      }
    }
    return ranks;
  };


  /*
  Given a array of cards, find out all the card values that belongs to the designated suit
  @param: suitIndex                       the suit index
  @param: cardValues                      the card values in which to look for
  @return: cardValuesForSuit              the card values that belongs to the given suit in the given card values
   */

  getCardValuesForSuit = function(suitIndex, cardValues) {
    var cardValuesForSuit, i, j, ref, startAndEndValuesForSuit;
    startAndEndValuesForSuit = getStartAndEndValueForSuit(suitIndex);
    cardValuesForSuit = [];
    for (i = j = 0, ref = cardValues.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (cardValues[i] >= startAndEndValuesForSuit[0] && cardValues[i] <= startAndEndValuesForSuit[1]) {
        cardValuesForSuit.push(cardValues[i]);
      }
    }
    return cardValuesForSuit;
  };


  /*
  Given the main suit index, this function finds out all card values that is either main card or main suit card
  @param: mainSuit                        the main suit index
  @return array                           all card values that is either main card or main suit card
   */

  getAllValuesOfMainAndMainSuit = function(mainSuit) {
    var i, j, k, ref, ref1, ref2, ref3, startAndEndValuesForMain, startAndEndValuesForMainSuit, valuesOfMainAndMainSuit;
    startAndEndValuesForMain = getStartAndEndValueForSuit(constants.INDEX_SUIT_MAIN);
    startAndEndValuesForMainSuit = getStartAndEndValueForSuit(mainSuit);
    valuesOfMainAndMainSuit = [];
    for (i = j = ref = startAndEndValuesForMain[0], ref1 = startAndEndValuesForMain[1] + 1; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      valuesOfMainAndMainSuit.push(i);
    }
    for (i = k = ref2 = startAndEndValuesForMainSuit[0], ref3 = startAndEndValuesForMainSuit[1] + 1; ref2 <= ref3 ? k < ref3 : k > ref3; i = ref2 <= ref3 ? ++k : --k) {
      valuesOfMainAndMainSuit.push(i);
    }
    return valuesOfMainAndMainSuit;
  };


  /*
  Given a suit index and card values at hand, this function finds out all pairs within card values at hand that are the given suit
  @param: suitIndex                       the given suit index
  @param: cardValuesAtHand                the card values at hand
  @return: array                          all the values of pairs that satisfies the condition
   */

  getAllPairValuesAtHandForSuit = function(suitIndex, cardValuesAtHand) {
    var cardValuesAtHandOfSuit, i, j, pairValues, ref;
    cardValuesAtHandOfSuit = getCardValuesForSuit(suitIndex, cardValuesAtHand);
    pairValues = [];
    if (cardValuesAtHandOfSuit.length === 0) {
      return pairValues;
    }
    for (i = j = 0, ref = cardValuesAtHandOfSuit.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (cardValuesAtHandOfSuit[i] === cardValuesAtHandOfSuit[i + 1]) {
        pairValues.push(cardValuesAtHandOfSuit[i]);
      }
    }
    return pairValues;
  };


  /*
  With the given suit as main suit, this function returns all related main suit card values
  @param: mainSuit                        the main suit index
  @return: mainSuitValues                 an array that contains card values including main seven, other sevens, main two, other twos and main ace
   */

  getRelativeMainSuitValues = function(mainSuit) {
    var mainSuitValues;
    mainSuitValues = {};
    switch (mainSuit) {
      case constants.INDEX_SUIT_SPADE:
        mainSuitValues.valueOfMainSuitOfSeven = constants.VALUE_SPADE_SEVEN;
        mainSuitValues.valuesOfRestSuitsOfSeven = [constants.VALUE_HEART_SEVEN, constants.VALUE_CLUB_SEVEN, constants.VALUE_DIAMOND_SEVEN];
        mainSuitValues.valueOfMainSuitOfTwo = constants.VALUE_SPADE_TWO;
        mainSuitValues.valuesOfRestSuitsOfTwo = [constants.VALUE_HEART_TWO, constants.VALUE_CLUB_TWO, constants.VALUE_DIAMOND_TWO];
        mainSuitValues.valueOfMainSuitOfAce = constants.VALUE_SPADE_ACE;
        break;
      case constants.INDEX_SUIT_HEART:
        mainSuitValues.valueOfMainSuitOfSeven = constants.VALUE_HEART_SEVEN;
        mainSuitValues.valuesOfRestSuitsOfSeven = [constants.VALUE_SPADE_SEVEN, constants.VALUE_CLUB_SEVEN, constants.VALUE_DIAMOND_SEVEN];
        mainSuitValues.valueOfMainSuitOfTwo = constants.VALUE_HEART_TWO;
        mainSuitValues.valuesOfRestSuitsOfTwo = [constants.VALUE_SPADE_TWO, constants.VALUE_CLUB_TWO, constants.VALUE_DIAMOND_TWO];
        mainSuitValues.valueOfMainSuitOfAce = constants.VALUE_HEART_ACE;
        break;
      case constants.INDEX_SUIT_CLUB:
        mainSuitValues.valueOfMainSuitOfSeven = constants.VALUE_CLUB_SEVEN;
        mainSuitValues.valuesOfRestSuitsOfSeven = [constants.VALUE_SPADE_SEVEN, constants.VALUE_HEART_SEVEN, constants.VALUE_DIAMOND_SEVEN];
        mainSuitValues.valueOfMainSuitOfTwo = constants.VALUE_CLUB_TWO;
        mainSuitValues.valuesOfRestSuitsOfTwo = [constants.VALUE_SPADE_TWO, constants.VALUE_HEART_TWO, constants.VALUE_DIAMOND_TWO];
        mainSuitValues.valueOfMainSuitOfAce = constants.VALUE_CLUB_ACE;
        break;
      case constants.INDEX_SUIT_DIAMOND:
        mainSuitValues.valueOfMainSuitOfSeven = constants.VALUE_DIAMOND_SEVEN;
        mainSuitValues.valuesOfRestSuitsOfSeven = [constants.VALUE_SPADE_SEVEN, constants.VALUE_HEART_SEVEN, constants.VALUE_CLUB_SEVEN];
        mainSuitValues.valueOfMainSuitOfTwo = constants.VALUE_DIAMOND_TWO;
        mainSuitValues.valuesOfRestSuitsOfTwo = [constants.VALUE_SPADE_TWO, constants.VALUE_HEART_TWO, constants.VALUE_CLUB_TWO];
        mainSuitValues.valueOfMainSuitOfAce = constants.VALUE_DIAMOND_ACE;
    }
    return mainSuitValues;
  };


  /*
  Check whether the card values contain at least 1 card of specific suit
  @param: suitIndex                           designated suit index
  @param: cardvaluesAtHand                    the given card values in which to search for
  @return: boolean                            true if at least one card of the suit in the array of card values, false otherwise
   */

  haveSingleForSuit = function(suitIndex, cardValues) {
    var cardValuesAtHandOfSuit;
    cardValuesAtHandOfSuit = getCardValuesForSuit(suitIndex, cardValues);
    if (cardValuesAtHandOfSuit.length > 0) {
      return true;
    } else {
      return false;
    }
  };

  haveSingleForMainSuit = function(mainSuit, cardValues) {
    var cardValuesAtHandForMain, cardValuesAtHandForMainSuit;
    cardValuesAtHandForMain = getCardValuesForSuit(constants.INDEX_SUIT_MAIN, cardValues);
    cardValuesAtHandForMainSuit = getCardValuesForSuit(mainSuit, cardValues);
    if (cardValuesAtHandForMain.length > 0 || cardValuesAtHandForMainSuit.length > 0) {
      return true;
    } else {
      return false;
    }
  };

  havePairForSuit = function(suitIndex, cardValues) {
    var cardValuesAtHandOfSuit, i, j, ref;
    cardValuesAtHandOfSuit = getCardValuesForSuit(suitIndex, cardValues);
    for (i = j = 0, ref = cardValuesAtHandOfSuit.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (cardValuesAtHandOfSuit[i] === cardValuesAtHandOfSuit[i + 1]) {
        return true;
      }
    }
    return false;
  };

  havePairForMainSuit = function(mainSuit, cardValues) {
    var cardValuesAtHandForMain, cardValuesAtHandForMainSuit, i, j, mains, ref;
    cardValuesAtHandForMain = getCardValuesForSuit(constants.INDEX_SUIT_MAIN, cardValues);
    cardValuesAtHandForMainSuit = getCardValuesForSuit(mainSuit, cardValues);
    mains = cardValuesAtHandForMain.concat(cardValuesAtHandForMainSuit);
    for (i = j = 0, ref = mains.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (mains[i] === mains[i + 1]) {
        return true;
      }
    }
    return false;
  };

  haveTractorForSuit = function(tractorLength, suitIndex, cardValues) {
    var i, j, numOfConsecutivePairs, pairValuesAtHandOfSuit, ref;
    pairValuesAtHandOfSuit = getAllPairValuesAtHandForSuit(suitIndex, cardValues);
    if (pairValuesAtHandOfSuit.length === 0) {
      return false;
    }
    if (pairValuesAtHandOfSuit.length < tractorLength) {
      return false;
    }
    numOfConsecutivePairs = 1;
    for (i = j = 0, ref = pairValuesAtHandOfSuit.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if ((pairValuesAtHandOfSuit[i] + 1) === pairValuesAtHandOfSuit[i + 1]) {
        numOfConsecutivePairs += 1;
        if (numOfConsecutivePairs === tractorLength) {
          return true;
        }
      } else {
        numOfConsecutivePairs = 0;
      }
    }
    return false;
  };

  haveTractorForMainSuit = function(tractorLength, mainSuit, cardValues) {
    var i, j, k, numOfConsecutivePairs, pairRanks, pairValuesAtHandOfMain, pairValuesAtHandOfSuit, pairs, ref, ref1;
    pairValuesAtHandOfMain = getAllPairValuesAtHandForSuit(constants.INDEX_SUIT_MAIN, cardValues);
    pairValuesAtHandOfSuit = getAllPairValuesAtHandForSuit(mainSuit, cardValues);
    pairs = pairValuesAtHandOfMain.concat(pairValuesAtHandOfSuit);
    if (pairs.length === 0) {
      return false;
    }
    if (pairs.length < tractorLength) {
      return false;
    }
    numOfConsecutivePairs = 1;
    pairRanks = [];
    for (i = j = 0, ref = pairs.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      pairRanks.push(globalVariables.cardValueRanks[pairs[i]]);
    }
    pairRanks = sortCards(pairRanks);
    for (i = k = 0, ref1 = pairRanks.length - 1; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      if ((pairRanks[i] + 1) === pairRanks[i + 1]) {
        numOfConsecutivePairs += 1;
        if (numOfConsecutivePairs === tractorLength) {
          return true;
        }
      } else {
        numOfConsecutivePairs = 0;
      }
    }
    return false;
  };

  isSingleForSuit = function(suitIndex, cardValues) {
    var startAndEndValuesForSuit;
    startAndEndValuesForSuit = getStartAndEndValueForSuit(suitIndex);
    if (cardValues.length === 1 && cardValues[0] >= startAndEndValuesForSuit[0] && cardValues[0] <= startAndEndValuesForSuit[1]) {
      return true;
    } else {
      return false;
    }
  };

  isSingleForMainSuit = function(mainSuit, cardValues) {
    var ref, valuesOfMainAndMainSuit;
    valuesOfMainAndMainSuit = getAllValuesOfMainAndMainSuit(mainSuit);
    if (cardValues.length === 1 && (ref = cardValues[0], indexOf.call(valuesOfMainAndMainSuit, ref) >= 0)) {
      return true;
    } else {
      return false;
    }
  };

  isPairForSuit = function(suitIndex, cardValues) {
    var startAndEndValuesForSuit;
    startAndEndValuesForSuit = getStartAndEndValueForSuit(suitIndex);
    if (cardValues.length === 2 && cardValues[0] === cardValues[1] && cardValues[0] >= startAndEndValuesForSuit[0] && cardValues[1] <= startAndEndValuesForSuit[1]) {
      return true;
    } else {
      return false;
    }
  };

  isPairForMainSuit = function(mainSuit, cardValues) {
    var ref, valuesOfMainAndMainSuit;
    valuesOfMainAndMainSuit = getAllValuesOfMainAndMainSuit(mainSuit);
    if (cardValues.length === 2 && cardValues[0] === cardValues[1] && (ref = cardValues[0], indexOf.call(valuesOfMainAndMainSuit, ref) >= 0)) {
      return true;
    } else {
      return false;
    }
  };

  isTractorForSuit = function(tractorLength, suitIndex, cardValues) {
    var i, j, pairRanks, ref, startAndEndValuesForSuit;
    if (tractorLength === 0 || cardValues.length < 4) {
      return false;
    }
    if (cardValues.length < tractorLength * 2 || cardValues.length % 2 !== 0) {
      return false;
    }
    startAndEndValuesForSuit = getStartAndEndValueForSuit(suitIndex);
    if (cardValues[0] < startAndEndValuesForSuit[0] || cardValues[cardValues.length - 1] > startAndEndValuesForSuit[1]) {
      return false;
    }
    i = 0;
    pairRanks = [];
    while (i <= (cardValues.length - 2)) {
      if (cardValues[i] !== cardValues[i + 1]) {
        return false;
      } else {
        pairRanks.push(globalVariables.cardValueRanks[cardValues[i]]);
      }
      i += 2;
    }
    pairRanks = sortCards(pairRanks);
    for (i = j = 0, ref = pairRanks.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if ((pairRanks[i] + 1) !== pairRanks[i + 1]) {
        return false;
      }
    }
    return true;
  };

  isTractorForMainSuit = function(tractorLength, mainSuit, cardValues) {
    var i, j, k, pairRanks, ref, ref1, ref2, valuesOfMainAndMainSuit;
    if (tractorLength === 0 || cardValues.length < 4) {
      return false;
    }
    if (cardValues.length < tractorLength * 2 || cardValues.length % 2 !== 0) {
      return false;
    }
    valuesOfMainAndMainSuit = getAllValuesOfMainAndMainSuit(mainSuit);
    for (i = j = 0, ref = cardValues.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (ref1 = cardValues[i], indexOf.call(valuesOfMainAndMainSuit, ref1) < 0) {
        return false;
      }
    }
    i = 0;
    pairRanks = [];
    while (i <= (cardValues.length - 2)) {
      if (cardValues[i] !== cardValues[i + 1]) {
        return false;
      } else {
        pairRanks.push(globalVariables.cardValueRanks[cardValues[i]]);
      }
      i += 2;
    }
    pairRanks = sortCards(pairRanks);
    for (i = k = 0, ref2 = pairRanks.length - 1; 0 <= ref2 ? k < ref2 : k > ref2; i = 0 <= ref2 ? ++k : --k) {
      if ((pairRanks[i] + 1) !== pairRanks[i + 1]) {
        return false;
      }
    }
    return true;
  };

  validateSelectedCardsForPlay = function(selectedCardValues, firstlyPlayedCardValues, cardValuesAtHand, mainSuit) {
    var numberOfCardsAtHandForSpecificSuit, numberOfCardsInSelectedCardsForSpecificSuit, numberOfMainCardsAtHand, numberOfMainCardsInSelectedCards, pairValuesAtHandOfSuit, selectedPairValuesOfSuit, suitForFirstlyPlayedCards;
    if (selectedCardValues.length === 0) {
      return false;
    }
    if (firstlyPlayedCardValues.length > 0) {
      suitForFirstlyPlayedCards = null;
      if (isSingleForMainSuit(mainSuit, [firstlyPlayedCardValues[0]])) {
        suitForFirstlyPlayedCards = constants.INDEX_SUIT_MAIN;
      } else if (isSingleForSuit(constants.INDEX_SUIT_SPADE, [firstlyPlayedCardValues[0]])) {
        suitForFirstlyPlayedCards = constants.INDEX_SUIT_SPADE;
      } else if (isSingleForSuit(constants.INDEX_SUIT_HEART, [firstlyPlayedCardValues[0]])) {
        suitForFirstlyPlayedCards = constants.INDEX_SUIT_HEART;
      } else if (isSingleForSuit(constants.INDEX_SUIT_CLUB, [firstlyPlayedCardValues[0]])) {
        suitForFirstlyPlayedCards = constants.INDEX_SUIT_CLUB;
      } else if (isSingleForSuit(constants.INDEX_SUIT_DIAMOND, [firstlyPlayedCardValues[0]])) {
        suitForFirstlyPlayedCards = constants.INDEX_SUIT_DIAMOND;
      }
      if (selectedCardValues.length !== firstlyPlayedCardValues.length) {
        return false;
      }
      if (suitForFirstlyPlayedCards === constants.INDEX_SUIT_MAIN) {
        numberOfMainCardsInSelectedCards = getCardValuesForSuit(constants.INDEX_SUIT_MAIN, selectedCardValues).length + getCardValuesForSuit(mainSuit, selectedCardValues).length;
        numberOfMainCardsAtHand = getCardValuesForSuit(constants.INDEX_SUIT_MAIN, cardValuesAtHand).length + getCardValuesForSuit(mainSuit, cardValuesAtHand).length;
        if (numberOfMainCardsInSelectedCards < firstlyPlayedCardValues.length && numberOfMainCardsInSelectedCards !== numberOfMainCardsAtHand) {
          return false;
        }
      } else {
        numberOfCardsInSelectedCardsForSpecificSuit = getCardValuesForSuit(suitForFirstlyPlayedCards, selectedCardValues).length;
        numberOfCardsAtHandForSpecificSuit = getCardValuesForSuit(suitForFirstlyPlayedCards, cardValuesAtHand).length;
        if ((numberOfCardsInSelectedCardsForSpecificSuit < firstlyPlayedCardValues.length) && (numberOfCardsInSelectedCardsForSpecificSuit !== numberOfCardsAtHandForSpecificSuit)) {
          return false;
        }
      }
      if (isSingleForMainSuit(mainSuit, firstlyPlayedCardValues)) {
        if (haveSingleForMainSuit(mainSuit, cardValuesAtHand) && !isSingleForMainSuit(mainSuit, selectedCardValues)) {
          return false;
        }
      } else if (isSingleForSuit(suitForFirstlyPlayedCards, firstlyPlayedCardValues)) {
        if (haveSingleForSuit(suitForFirstlyPlayedCards, cardValuesAtHand) && !isSingleForSuit(suitForFirstlyPlayedCards, selectedCardValues)) {
          return false;
        }
      } else if (isPairForMainSuit(mainSuit, firstlyPlayedCardValues)) {
        if (havePairForMainSuit(mainSuit, cardValuesAtHand)) {
          if (!isPairForMainSuit(mainSuit, selectedCardValues)) {
            return false;
          }
        }
      } else if (isPairForSuit(suitForFirstlyPlayedCards, firstlyPlayedCardValues)) {
        if (havePairForSuit(suitForFirstlyPlayedCards, cardValuesAtHand)) {
          if (!isPairForSuit(suitForFirstlyPlayedCards, selectedCardValues)) {
            return false;
          }
        }
      } else if (isTractorForMainSuit(firstlyPlayedCardValues.length / 2, mainSuit, firstlyPlayedCardValues)) {
        if (haveTractorForMainSuit(firstlyPlayedCardValues.length / 2, mainSuit, cardValuesAtHand)) {
          if (!isTractorForMainSuit(selectedCardValues.length / 2, mainSuit, selectedCardValues)) {
            return false;
          }
        }
        pairValuesAtHandOfSuit = getAllPairValuesAtHandForSuit(constants.INDEX_SUIT_MAIN, cardValuesAtHand);
        pairValuesAtHandOfSuit = pairValuesAtHandOfSuit.concat(getAllPairValuesAtHandForSuit(mainSuit, cardValuesAtHand));
        selectedPairValuesOfSuit = getAllPairValuesAtHandForSuit(constants.INDEX_SUIT_MAIN, selectedCardValues);
        selectedPairValuesOfSuit = selectedPairValuesOfSuit.concat(getAllPairValuesAtHandForSuit(mainSuit, selectedCardValues));
        if (selectedPairValuesOfSuit.length < firstlyPlayedCardValues.length / 2) {
          if ((selectedPairValuesOfSuit.length !== pairValuesAtHandOfSuit.length) && (pairValuesAtHandOfSuit.length !== 0)) {
            return false;
          }
        }
      } else if (isTractorForSuit(firstlyPlayedCardValues.length / 2, suitForFirstlyPlayedCards, firstlyPlayedCardValues)) {
        if (haveTractorForSuit(firstlyPlayedCardValues.length / 2, suitForFirstlyPlayedCards, cardValuesAtHand)) {
          if (!isTractorForSuit(selectedCardValues.length / 2, suitForFirstlyPlayedCards, selectedCardValues)) {
            return false;
          }
        }
        pairValuesAtHandOfSuit = getAllPairValuesAtHandForSuit(suitForFirstlyPlayedCards, cardValuesAtHand);
        selectedPairValuesOfSuit = getAllPairValuesAtHandForSuit(suitForFirstlyPlayedCards, selectedCardValues);
        if (selectedPairValuesOfSuit.length < firstlyPlayedCardValues.length / 2) {
          if (selectedPairValuesOfSuit.length !== pairValuesAtHandOfSuit.length && pairValuesAtHandOfSuit.length !== 0) {
            return false;
          }
        }
      }
    } else {
      if ((selectedCardValues.length > 1) && (selectedCardValues.length % 2 !== 0)) {
        return false;
      }
      if ((selectedCardValues.length === 2) && (selectedCardValues[0] !== selectedCardValues[1])) {
        return false;
      }
      if (selectedCardValues.length >= 4) {
        if (isTractorForSuit(selectedCardValues.length / 2, constants.INDEX_SUIT_SPADE, selectedCardValues)) {
          return true;
        } else if (isTractorForSuit(selectedCardValues.length / 2, constants.INDEX_SUIT_HEART, selectedCardValues)) {
          return true;
        } else if (isTractorForSuit(selectedCardValues.length / 2, constants.INDEX_SUIT_CLUB, selectedCardValues)) {
          return true;
        } else if (isTractorForSuit(selectedCardValues.length / 2, constants.INDEX_SUIT_DIAMOND, selectedCardValues)) {
          return true;
        } else if (isTractorForMainSuit(selectedCardValues.length / 2, mainSuit, selectedCardValues)) {
          return true;
        } else {
          return false;
        }
      }
    }
    return true;
  };

  module.exports = {
    sortCards: sortCards,
    getCardName: getCardName,
    validateSelectedCardsForPlay: validateSelectedCardsForPlay,
    getCardValuesForSuit: getCardValuesForSuit,
    havePairForSuit: havePairForSuit,
    haveSingleForSuit: haveSingleForSuit,
    getAllPairValuesAtHandForSuit: getAllPairValuesAtHandForSuit,
    haveTractorForSuit: haveTractorForSuit,
    getRanksForMainSuitCards: getRanksForMainSuitCards,
    setPlayerStatusTextForOneUserAndClearStatusTextForOthers: setPlayerStatusTextForOneUserAndClearStatusTextForOthers,
    sortCardsAfterMainSuitSettled: sortCardsAfterMainSuitSettled,
    binarySearch: binarySearch
  };

}).call(this);
